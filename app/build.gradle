/*
 * Copyright (c) 2014 Mohit Kanwal.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 */

import org.gradle.internal.os.OperatingSystem

apply plugin: 'com.android.application'
def BUILD_TOOLS_VERSION = "19.1.0"
android {
    compileSdkVersion 19
    buildToolsVersion BUILD_TOOLS_VERSION

    defaultConfig {
        minSdkVersion 10
        targetSdkVersion 19
        versionCode 1
        versionName "1.0"
    }

    // Need to disable pre dexing to be able to build properly
    // Otherwise we need to add more tasks to the libraries
    // This is a small penalty to keep the house in order!
    dexOptions {
        incremental false
        preDexLibraries = false
        jumboMode = false
    }
    enforceUniquePackageName false

    buildTypes {
        release {
            runProguard true
            minifyEnabled true
            debuggable false
            zipAlign true
            proguardFiles 'proguard-rules.txt'
            signingConfig debug.signingConfig
        }
    }
}
/**
 * Relies on the Bash Script to manipulate the Dexing of the correct classes.
 */
 // 这里基于Project.afterEvaluate()方法，保证在Evaluate完成后被执行到
afterEvaluate { project ->
    android.applicationVariants.each {
        variant ->
            // 取到SDK的主目录，用于后面获取build tools目录下的dx工具所用
            String SDK_DIR = System.getenv("ANDROID_HOME")
            if (SDK_DIR == null) {
                // 如果取不到就到local.properties中取sdk.dir的值
                Properties props = new Properties()
                props.load(new FileInputStream(project.rootProject.file("local.properties")))
                SDK_DIR = props.get('sdk.dir');
            }
            // 由于最终编译后所打的包包名默认会包含flavor
            String FLAVOR = "${variant.flavorName}"
            // 用于获取当前版本dx工具绝对路径
            String BUILD_TYPE = "${variant.buildType.name}"
            // 用于最终输出目录
            String ASSET_DIR = "${variant.mergeAssets.outputDir}"
            // 获取dx工具绝对路径
            String DEX = "${SDK_DIR}/build-tools/${BUILD_TOOLS_VERSION}/dx"
            String BUILD_TOOL_DX = OperatingSystem.current().windows ? "${DEX}.bat" : "${DEX}"
            // dex将会输出的目录名
            String EX_DIR = "classes"

            String LIB_NAME = ""
            if ("$FLAVOR" != "")
                LIB_NAME = "app-${FLAVOR}-${BUILD_TYPE}"
            else
                LIB_NAME = "app-${BUILD_TYPE}"

            String taskDexSplit = "dex${variant.name.capitalize()}Split"
            String taskDexSplit2 = taskDexSplit + "2"

            // 作者用minifyEnabled，来判断是否是有混淆，其实也可以理解啦，因为minifyEnabled是基于混淆的
            if (variant.buildType.minifyEnabled) {

                task("$taskDexSplit") << {

                    // 工作目录，以proguard后的源码目录作为工作
                    String WORKDIR
                    if ("$FLAVOR" != "")
                        WORKDIR = "build/intermediates/classes-proguard/${FLAVOR}/${BUILD_TYPE}"
                    else
                        WORKDIR = "build/intermediates/classes-proguard/${BUILD_TYPE}"

                    task("unzipAndDeleteClassesJar", type: Copy) {
                        // 将混淆后的classes.jar解压缩到outputDir
                        def zipFile = file("${WORKDIR}/classes.jar")
                        def outputDir = file("${WORKDIR}/${EX_DIR}")
                        from zipTree(zipFile)
                        into outputDir
                        // 任务执行之前
                        doFirst {
                            outputDir.deleteDir()
                        }
                        // 任务执行之后
                        doLast {
                            zipFile.delete()
                        }
                    }.execute()

                    task("extractLibraryClasses", type: Copy) {
                        // 需要打到单独dex的包目录
                        String PACKAGE = "com/github/creativepsyco/secondarydex/bigmodule/lib"
                        // proguard后源码所在目录
                        def source = file("${WORKDIR}/${EX_DIR}/${PACKAGE}/")
                        // 将需要打到独立dex的文件拷贝到OUTPACKAGE目录
                        from source
                        into file("${WORKDIR}/OUTPACKAGE/${PACKAGE}/")
                        // 任务执行完后
                        doLast {
                            source.deleteDir()
                        }
                    }.execute()

                    task("extractGuavaLibrary", type: Copy) {
                        // 将com.google.**包名下的所有拷贝到需要打独立dex的目录下
                        String PACKAGE = "com/google"
                        def source = file("${WORKDIR}/${EX_DIR}/${PACKAGE}/")
                        from source
                        into file("${WORKDIR}/OUTPACKAGE/${PACKAGE}/")
                        doLast {
                            source.deleteDir()
                        }
                    }.execute()

                    task("rebuildClassesJar", type: Exec) {
                        // 将解压出来，抛离了需要独立dex文件的class重新打包回classes.jar
                        commandLine "jar", "cvf", "${WORKDIR}/classes.jar", "-C", "${WORKDIR}/${EX_DIR}/", "."
                    }.execute()

                    task("dexLibraries", type: Exec) {
                        // 将需要独立dex的所有class文件，打dex并输出到assets目录
                        commandLine "${BUILD_TOOL_DX}", "--dex", "--output=${ASSET_DIR}", "${WORKDIR}/OUTPACKAGE"
                    }.execute()
                }

                if (variant.variantData.obfuscationTask != null) {
                    println "[Dexing] Adding Task to run after proguard"
                    tasks.findByName(taskDexSplit).dependsOn variant.variantData.obfuscationTask
                } else {
                    println "[Dexing] Obfuscation task is null ${variant.variantData}"
                }

            } else {

                // 这是没有proguard的包
                // For Debug simply remove the library from getting dex and create it
                //----------------------- Extra Debug Step ----------------//
                def libraryFiles = new ArrayList<?>()
                def secondaryFile = new ArrayList<?>()

                // 遍历并区分出需独立dex与主dex的文件
                variant.dex.libraries.each {
                    File file ->
                            // 不包含 lib/unspecified/classes.jar && 不包含guava
                        if (!file.absolutePath.contains("lib${File.separator}unspecified${File.separator}classes.jar")
                                && !file.absolutePath.contains("guava")) {
                            libraryFiles.add(file)
                        } else {
                            secondaryFile.add(file)
                        }
                }
                variant.dex.libraries = libraryFiles
                //----------------------- Extra Debug Step ----------------//

                // 拆分dex任务
                task("$taskDexSplit") << {
                    def arguments = new ArrayList<?>()
                    arguments.add("--dex")
                    arguments.add("--output=${ASSET_DIR}")
                    arguments.addAll(secondaryFile)

                    // 将独立dex打好并放入asset中
                    task("dexLibraries", type: Exec) {
                        executable "${BUILD_TOOL_DX}"
                        args arguments
//                        commandLine "${BUILD_TOOL_DX}", "--dex", "--output=${ASSET_DIR}"
//                        commandLine.addAll(secondaryFile)
                    }.execute()
                }

                tasks.findByName(taskDexSplit).dependsOn variant.javaCompile
            }

            task("$taskDexSplit2") << {

                // 将拆分出来的dex进行压缩进game.zip并且删除assets目录下的classes.dex
                task("zipDexedLibraries", type: Zip) {
                    destinationDir new File("${ASSET_DIR}")
                    archiveName 'game.zip'
                    from "${ASSET_DIR}"
                    include '*.dex'
                    doLast {
                        file("${ASSET_DIR}/classes.dex").delete()
                    }
                }.execute()

                task("copyDexedLibrariesToApp", type: Copy) {
                    from "${ASSET_DIR}/game.zip"
                    into "build/intermediates/libs/${LIB_NAME}/assets/"
                }.execute()
            }
/*
            tasks.findByName(taskDexSplit).onlyIf(new Spec<Task>() {
                boolean isSatisfiedBy(Task task) {
                    return task.dependsOnTaskDidWork();
                }
            })

            tasks.findByName(taskDexSplit2).onlyIf(new Spec<Task>() {
                boolean isSatisfiedBy(Task task) {
                    return task.dependsOnTaskDidWork();
                }
            })
*/

            // Finally Depend on Dex Task
            String dexTaskName = "dex${variant.variantData.name.capitalize()}"
            Task dexTask = tasks.findByName(dexTaskName)
            dexTask.dependsOn taskDexSplit2
            tasks.findByName(taskDexSplit2).dependsOn taskDexSplit
    }
}
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:19.+'
    compile project(':lib')
    compile 'com.google.guava:guava:18.0'
}
